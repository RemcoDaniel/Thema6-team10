enum class maken voor de wasprogramma's

meer inheritens

const char * maken

pools samenvoegen  (motor task)

in de controllers: niet char * returnen!!!


wasprogramma maken

verhaaltje schrijven over forward declaren in verslag!

fatal error: callback timer destructor called


=================================================================

toen er aan de code werd gewerkt, bleek een probleem te ontstaan.
De WashingMachineController heeft namelijk 3 controllers onder zich, de
WaterController, de TempController en de MotorController.
Dit zijn allemaal taken en er moet tussen deze taken en de WashingMachineController taak
communicatie plaats kunnen vinden.
Ze moeten elkaar dus kennen, in beide richtingen.
Verder moeten al deze 4 de controllers met de UART taak kunnen communiceren.
Dus zouden ze ook allemaal een verwijzing moeten hebben naar de uart en andersom.
Maar nu komt het probleem:
bij het aanmaken van de objecten ontstond als het ware een kip-ei-probleem.
Ze waren allemaal afhankelijk van elkaars bestaan bij het aanmaken.
Bij het uittekenen ontstond een soort driehoeksverhouding zoals te zien in de afbeelding
hieronder.
Een oplossing leek om deze driehoek te doorbreken en de WashingMachineController
niet meer met de UART te laten communiceren.
Door een extra controller toe te voegen zou de nodige communicatie dan alsnog
via een kleine omweg plaats kunnen vinden.
Dit is te zien in de volgende afbeelding.
Echter na wat uitdenken bleek dat het probleem weliswaar kleiner was geworden,
maar dat het probleem nogsteeds aanwezig was, maar dan binnen de WashingMachineController.

Een andere oplossing zou zijn om de WashingMachineController alsnog alle controllers
aan te laten maken en zichzelf mee te geven als parameter.
Echter dit keer zonder UART maar met een lege shared pointer die straks naar de uart
zou kunnen wijzen.
Vervolgens kan de UART aan worden gemaakt en in zijn constructoraanroep als
parameters de controllers mee kunnen krijgen.
Nu de uart bestaat kan per controller de shared pointer naar de uart worden
ingevuld en is de cirkel rond.

===========================================================================

// file UART.cpp

#include "UART.h"
#include <iostream>

UART::UART(const char * device, unsigned int baudrate, MotorController * motorctrl, TempController * tempctrl, WaterController * waterctrl, WashingMachineController * wasctrl):
	task{ 0, "uart" },			// de priority moet nog goed worden ingesteld
	device{ device },
	baudrate{baudrate},
	motorctrl{motorctrl},
	tempctrl{tempctrl},
	waterctrl{waterctrl},
	wasctrl{wasctrl},
	interval_clock{ this, 10 MS, "interval" },
	commandchannel{this, "channel"}
{
	int portMakeState = theSerialPort.open(device, baudrate);
	//if (portMakeState < 1){
	//	throw(uart_error(std::string{ "" } + device + " with error value " + char(portMakeState)));
	//}
}

void UART::executeCommand(char * s){
	theSerialPort.writeString(s);

	while(theSerialPort.peek() < 2){
		wait(interval_clock);
	}
	
	char * response;
	theSerialPort.readString(response, char(0xFF), 2);
	returnResponse(response);
}

void UART::readChannel() {
	executeCommand(commandchannel.read());
}

void UART::returnResponse(char * response) {
	std::cout << "uart giving response\n";
	switch (response[0]) {
		case '0x09':
		case '0x0A': 	motorctrl->writeResponse(response); motorctrl->setResponseFlag();	break;	// motortaak
		case '0x07':
		case '0x08': 	tempctrl->writeResponse(response); tempctrl->setResponseFlag();		break;	// temperatuurtaak
		case '0x03':
		case '0x05':
		case '0x06': 	waterctrl->writeResponse(response); waterctrl->setResponseFlag();	break;	// watertaak
		case '0x01':
		case '0x02':
		case '0x04':
		case '0x0B': 	wasctrl->writeResponse(response); wasctrl->setResponseFlag();		break;	// wasmachinetaak
		default:		std::cout << "andere response\n";									break;
	}
}

void UART::writeChannel(char * request) {
	commandchannel.write(request);
}

void UART::main() {
	//=========================================================================
	// dit moet eerst!!!:
	char start_machine[3] = { MACHINE_REQ, START_CMD, '\0' };
	executeCommand(start_machine);
	//=========================================================================
	std::cout << "uart started\n";
	for (;;) {
		readChannel();
		wait(interval_clock);
	}
}
